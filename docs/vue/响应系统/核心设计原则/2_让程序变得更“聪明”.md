# 让程序变得更“聪明”

> 如果我们能够在 product 的数量发生变化时，重新执行总价的运算就好了。

那么如何去做呢？我们可以这样来：

1. 创建一个 `effect` 函数，在其内部封装 **计算总价格的表达式**
2. 在第一次打印总价格之前，执行 `effect` 方法
3. 在第二次打印总价格之前，执行 `effect` 方法

这样子，我们就可以在第二次打印的时候，得到 `50`。

```js
// 定义一个商品对象，包含价格和数量
const product = {
  price: 10,
  quantity: 2,
};

// 总价格
let total = 0;

// 计算总价格的函数
function effect() {
  total = product.price * product.quantity;
}

effect();
// 第一次打印
console.log(`总价格：${total}`); // 20

// 修改商品数量
product.quantity = 5;

effect();
// 第二次打印
console.log(`总价格：${total}`); // 50
```

通过这样的修改，我们在第二次打印的时候，得到了 `50`，也就是 **数据变化了，运算也重新执行了**

但是现在存在一个明显的问题：**必须主动在数量发生变化后，重新主动执行 `effect`**，才能得到想要的结果，这样未免也太麻烦了，有什么好办法吗？
