# 1-10000 之间的对称数（回文）

## 题目

打印 1-10000 之间的对称数

## 解法 1：数组反转

- 数字转换为字符串
- 字符串转换为数组，然后 reverse，然后 join 变回字符串
- 比较前后字符串

## 解法 2：字符串头尾比较

- 数字转换为字符串
- 字符串头尾比较

还可以使用**栈**（但栈会用到数组，性能不如直接操作字符串，类似于**括号匹配**）

- 数字转化为字符串，求长度
- 如果长度是偶数，则用栈比较
- 如果长度是奇数，则忽略中间的数字，其他的用栈比较

## 解法 3：使用反转数

- 通过 `%` 和 `Math.floor` 将数字变成反转数
- 比较前后的数字

## 性能分析

时间复杂度看似相当，都是`O(n)`

但 解法 1 设计到了数组的转换和数组的 reverse 操作，就需要耗费大量的时间

- 数组 reverse 需要时间
- 数组和字符串的转换需要时间

解法 2 和 解法 3 比较，数字操作最快。因为电脑的原型就是计算器，所以处理数字是最快的。

## 备注

- 尽量不适用内置 API，如 `reverse`，不好判断时间复杂度
- 尽量不要转换数据格式，尤其是数组（数组是有序结构）
- 数字操作最快
